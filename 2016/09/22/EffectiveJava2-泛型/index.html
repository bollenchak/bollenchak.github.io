<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Effective Java,generic," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="泛型
声明中具有一个或多个类型参数的类或者接口，称之为泛型(generic)类或接口。泛型类和泛型接口统称为泛型(generic type)
每个泛型都有一个原生态类型(raw type)，即不带任何实际类型参数的泛型名称。例如：List&amp;lt;E&amp;gt;对应的原生态类型是List。

在类进行编译时编译器自动进行类型转换，并且在编译时告知是否插入类型错误的对象，并在运行时擦除它们的元素类型。
泛">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Java - 泛型">
<meta property="og:url" content="http://bollenchak.github.io/2016/09/22/EffectiveJava2-泛型/index.html">
<meta property="og:site_name" content="Bollen's Notes">
<meta property="og:description" content="泛型
声明中具有一个或多个类型参数的类或者接口，称之为泛型(generic)类或接口。泛型类和泛型接口统称为泛型(generic type)
每个泛型都有一个原生态类型(raw type)，即不带任何实际类型参数的泛型名称。例如：List&amp;lt;E&amp;gt;对应的原生态类型是List。

在类进行编译时编译器自动进行类型转换，并且在编译时告知是否插入类型错误的对象，并在运行时擦除它们的元素类型。
泛">
<meta property="og:updated_time" content="2016-09-23T07:07:56.258Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective Java - 泛型">
<meta name="twitter:description" content="泛型
声明中具有一个或多个类型参数的类或者接口，称之为泛型(generic)类或接口。泛型类和泛型接口统称为泛型(generic type)
每个泛型都有一个原生态类型(raw type)，即不带任何实际类型参数的泛型名称。例如：List&amp;lt;E&amp;gt;对应的原生态类型是List。

在类进行编译时编译器自动进行类型转换，并且在编译时告知是否插入类型错误的对象，并在运行时擦除它们的元素类型。
泛">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Effective Java - 泛型 | Bollen's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-75849261-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Bollen's Notes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Write Technology Record</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Effective Java - 泛型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-22T21:16:21+08:00" content="2016-09-22">
              2016-09-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/22/EffectiveJava2-泛型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/22/EffectiveJava2-泛型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><blockquote>
<p>声明中具有一个或多个类型参数的类或者接口，称之为泛型(generic)类或接口。泛型类和泛型接口统称为泛型(generic type)</p>
<p>每个泛型都有一个原生态类型(raw type)，即不带任何实际类型参数的泛型名称。例如：List&lt;E&gt;对应的原生态类型是List。</p>
</blockquote>
<p>在类进行编译时编译器自动进行类型转换，并且在编译时告知是否插入类型错误的对象，并在运行时擦除它们的元素类型。</p>
<p><em>泛型相关术语</em></p>
<table>
<thead>
<tr>
<th>术语</th>
<th>实例</th>
<th>所在条目</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数化的类型</td>
<td>List&lt;String&gt;</td>
<td>第23条</td>
</tr>
<tr>
<td>实际类型参数</td>
<td>String</td>
<td>第23条</td>
</tr>
<tr>
<td>泛型</td>
<td>List&lt;E&gt;</td>
<td>第23、26条</td>
</tr>
<tr>
<td>形式类型参数</td>
<td>E</td>
<td>第23条</td>
</tr>
<tr>
<td>无限制通配符类型</td>
<td>List&lt;?&gt;</td>
<td>第23条</td>
</tr>
<tr>
<td>原生态类型</td>
<td>List</td>
<td>第23条</td>
</tr>
<tr>
<td>有限制类型参数</td>
<td>&lt;E extends Number&gt;</td>
<td>第26条</td>
</tr>
<tr>
<td>递归类型参数</td>
<td>&lt;T extends Comparable&lt;T&gt;&gt;</td>
<td>第27条</td>
</tr>
<tr>
<td>有限制通配符类型</td>
<td>List&lt;? extends Number&gt;</td>
<td>第28条</td>
</tr>
<tr>
<td>泛型方法</td>
<td>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</td>
<td>第27条</td>
</tr>
<tr>
<td>类型令牌</td>
<td>String.class</td>
<td>第29条</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="第23条-不要再新代码中使用原生态类型"><a href="#第23条-不要再新代码中使用原生态类型" class="headerlink" title="第23条 不要再新代码中使用原生态类型"></a>第23条 不要再新代码中使用原生态类型</h2><p>Java1.5发行版中增加了泛型。在没增加之前，都使用原生态类型。在此之后，泛型使程序更具有安全性和更好的表述性。为了保证移植兼容性，Java平台依然允许使用原生态类型，但在新代码中不要使用它们。</p>
<ul>
<li>泛型使得错误的发现提前，编译时就发现，降低了系统异常的风险</li>
<li>set&lt;Object&gt;参数化类型，表示可以包含任何对象类的一个集合；</li>
<li>set&lt;?&gt;无限制通配符类型，表示可以包含某种未知对象类型的一个集合；</li>
<li>set原生态类型，脱离了泛型系统不安全</li>
</ul>
<h2 id="第24条-消除非受检的警告"><a href="#第24条-消除非受检的警告" class="headerlink" title="第24条 消除非受检的警告"></a>第24条 消除非受检的警告</h2><p>使用泛型编程时会经常遇到很多非受检的警告。大多数警告很容易消除，有些比较难消除，在确保警告的代码是类型安全时可以通过<code>@SuppressWarnning(&quot;unchecked&quot;)</code>注解消除警告。</p>
<ul>
<li>尽可能消除每一个非受检警告，确保代码类型安全。这样程序就不会抛出<code>ClassCastException</code>异常。</li>
<li><code>@SuppressWarnning(&quot;unchecked&quot;)</code>注解尽可能写在影响范围小的区域，最好写在警告代码所在行上方。</li>
</ul>
<ul>
<li>每当使用<code>@SuppressWarnning(&quot;unchecked&quot;)</code>注解消除警告时都要添加一条注解说明为什么是安全的。</li>
</ul>
<h2 id="第25条-泛型列表优先于泛型数组"><a href="#第25条-泛型列表优先于泛型数组" class="headerlink" title="第25条 泛型列表优先于泛型数组"></a>第25条 泛型列表优先于泛型数组</h2><ul>
<li>协变的(covariant)解释</li>
</ul>
<p>如果类Sub是类Super的子类，那么数组类型Sub[]就是Super[]的子类型，因此数组是协变的。但泛型不是协变的，因此List&lt;Sub&gt;不是List&lt;Super&gt;的子类型，后者也不是前者的父类型。看似泛型有劣势，实际上这确是它的优势所在。</p>
<ul>
<li>具体化的(reified)解释</li>
</ul>
<p>具体化的——运行时表示法包含的信息和编译时表示法包含相同的类型信息。数组能够在运行时知道并检查元素类型的约束，如果你把一个String对象存入Long数组中就会得到ArrayStoreException异常。反之，泛型只是在编译期对它的类型信息进行强化，运行期会擦除类型信息以兼容原生态类型，运行时类型信息比编译时少，因此泛型是不可具体化的(non-reifiable)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">reduce</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">  		<span class="comment">//此处编译时有警告，运行时会擦除泛型，协变成其他子类型的数组</span></span><br><span class="line">		E[] xx = (E[]) list.toArray();</span><br><span class="line">		E result = xx[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组是协变的且可具体化的，因此泛型数组E[]会在运行时擦除泛型参数E，可能协变为String[]、Integer[]、Long[]等等，使用时造成类型转换异常。而泛型使不可协变的，因此编译时是安全的。如果发现泛型数组编译警告就应当用列表替代数组。</p>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h3><p>并不可能总是在泛型中使用列表，<code>Java</code>不是天生支持列表，因此有些泛型如:<code>ArrayList</code>必须在数组上实现。为了提升性能，泛型<code>HashMap</code>也在数组上实现。</p>
<h2 id="第26条-优先考虑泛型"><a href="#第26条-优先考虑泛型" class="headerlink" title="第26条 优先考虑泛型"></a>第26条 优先考虑泛型</h2><p>使用JDK或其他类库提供的泛型比较简单，但是自己编写泛型就不那么简单了。</p>
<h3 id="类泛型化的步骤"><a href="#类泛型化的步骤" class="headerlink" title="类泛型化的步骤"></a>类泛型化的步骤</h3><ol>
<li>类声明中添加一个或者多个类型参数，这个参数的名称通常是<code>E</code>（原因详见第44条）</li>
<li>用相应的类型参数替换类中所有的Object类型</li>
</ol>
<h3 id="泛型化的优势"><a href="#泛型化的优势" class="headerlink" title="泛型化的优势"></a>泛型化的优势</h3><p> 泛型化的类中进行类型转换比客户端自己进行类型转换更安全、更方便。</p>
<h2 id="第27条-优先考虑泛型方法"><a href="#第27条-优先考虑泛型方法" class="headerlink" title="第27条 优先考虑泛型方法"></a>第27条 优先考虑泛型方法</h2><p>静态工具方法尤其适合泛型化。例如，Collections中所有的算法方法都已经泛型化。</p>
<p>这句话有点拗口，声明方法的参数的 形式类型参数 列表，位于方法修饰符和返回类型之间。如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法修饰符 private 返回类型E  参数List&lt;E&gt;  形式类型列表 &lt;E&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">reduce</span><span class="params">(List&lt;E&gt; list)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>通过某个包含该类型参数本身的表达式来限制类型参数，称之为<em>递归类型限制</em> 。递归类型限制最普遍的应用在于定义类型的自然顺序的Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法就像泛型一样，泛型化方法使用起来比要求客户端转换输入参数更安全、更容易。</p>
<h2 id="第28条-利用有限制通配符来提升API的灵活性"><a href="#第28条-利用有限制通配符来提升API的灵活性" class="headerlink" title="第28条 利用有限制通配符来提升API的灵活性"></a>第28条 利用有限制通配符来提升API的灵活性</h2><ol>
<li>泛型参数化类型是不可协变的，意味着我们不能使用参数化类型逻辑上的子类型</li>
</ol>
<p>例如,Stack&lt;Number&gt;理应可以使用子类型的Stack&lt;Integer&gt;的intVal，但实际就会因为参数化类型不可协变而编译报错。但有时我们需要更大的灵活性，幸好Java提供了一种特殊的参数化类型——<strong>有限制的通配符</strong> ，可以处理类似的情况。上述例子即可采用<code>Statck&lt;? extends Number&amp;&gt;</code> 解决。这里的extends并不单指继承，而且包含被“继承”的自身——Number。</p>
<p>反之，如果要将Stack&lt;Number&gt;的一个元素取出放入Stack&lt;Integer&gt;中，就会因为泛型是不可协变的（即使互为父子关系的形式类型参数）出现上述例子中的错误。</p>
<p>同样的Java也提供了一种特殊的应对办法，即<code>Stack&lt;? super Integer&gt;</code>。这里的super也不单指父类，也包含自身</p>
<p><strong>结论</strong> ：为了获得最大限度的灵活性，要在生产者(写入)和消费者(读取)的读入参数上使用通配符类型。使用的基本原则是PECS。如果既是P又是C就不要用通配符，因为要严格匹配类型。<br>助记符 PECS 表示 producer-extends , consumer-super </p>
<p>   ​</p>
<ol>
<li>不要再返回值类型里使用通配符类型，它会强制用户在客户端代码中使用通配符类型</li>
</ol>
<p>不使用通配符类型，进行类型推导十分麻烦。但是不加编译会报错<figure class="highlight plain"><figcaption><span>types``` ，幸运的是可以通过**显式的类型参数**来告诉它要使用哪种类型。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//返回通配符类型的方法</span><br><span class="line">private static &lt;E&gt; Set&lt;? extends E&gt; union(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)&#123;...&#125;</span><br><span class="line">//两个参数</span><br><span class="line">Set&lt;Integer&gt; integers  = ...;</span><br><span class="line">Set&lt;Double&gt; doubles = ...;</span><br><span class="line">//类型推导不知道结果该为Number呢、还是Number的子类们呢</span><br><span class="line">//所以类型推导编译会报错 incompatible types</span><br><span class="line">Set&lt;Number&gt; numbers=  union(integers,doubles);</span><br><span class="line">//显式类型参数指定，虽然不优雅，但这样就不会报错了</span><br><span class="line">Set&lt;Number&gt; number = Union.&lt;Number&gt;union(integers,doubles);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>类型参数和通配符具有双重性，许多方法都可选其一进行声明</li>
</ol>
<p>在公共API中最好使用通配符代替类型参数，无限制类型参数&lt;E&gt;用无限制通配符&lt;?&gt;代替。有限制通类型参数&lt;E extends Number&gt;用有限制通配符代替。因为这样能保持API简洁，复杂的方法声明中类型名称的增多会降低方法的可读性。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T element)</span></span>;</span><br><span class="line">&#125;      </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebox</span><span class="params">(Box&lt;?&gt; box)</span> </span>&#123;...&#125;  <span class="comment">//优先使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> &lt;E&gt; rebox(Box&lt;E&gt; box)&#123;...&#125;<span class="comment">//被替换掉</span></span><br><span class="line"><span class="comment">//优先使用的看似没问题，但是当进行put时会编译异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebox</span><span class="params">(Box&lt;?&gt; box)</span> </span>&#123;</span><br><span class="line">   box.put(box.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Rebox.java:8: put(capture#337 of ?) in Box&lt;capture#337 of ?&gt; cannot be applied</span></span><br><span class="line"><span class="comment">//  to (java.lang.Object)</span></span><br><span class="line"><span class="comment">//   box.put(box.get());</span></span><br><span class="line"><span class="comment">//      ^</span></span><br><span class="line"><span class="comment">//1 error</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// “capture#337 of ?” 与 Object 不兼容的错误消息</span></span><br><span class="line"><span class="comment">//通配符意味着某个T，虽然不知道是哪个具体类型，可以通过占位符指代具体类型。占位符被称为这个特殊通配符的捕获（capture），每个通配符都会获得一个不同的捕获。</span></span><br><span class="line"><span class="comment">//因此box.get() 和box.put()两个捕获，第一个捕获get()类型是object，因为"?"实际是"? extends Object"，put()的捕获是"capture#337 of ?"，编译器不能静态地检验对由占位符 “capture#337 of ?” 所识别的类型而言 Object 是否是一个可接受的值。</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">//通过辅助方法这一技巧， 泛型方法引入了额外的类型参数（位于返回类型之前的尖括号中），这些参数用于表示参数和/或方法的返回值之间的类型约束。get()不再是object而是v,并将v传给put()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebox</span><span class="params">(Box&lt;?&gt; box)</span> </span>&#123;</span><br><span class="line">   reboxHelper(box);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>&lt;V&gt; <span class="keyword">void</span> <span class="title">reboxHelper</span><span class="params">(Box&lt;V&gt; box)</span> </span>&#123;</span><br><span class="line">   box.put(box.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   <a href="http://www.ibm.com/developerworks/cn/java/j-jtp04298.html" target="_blank" rel="external">参考资料</a> Java 理论与实践: 使用通配符简化泛型使用 </p>
<p>   <a href="http://www.ibm.com/developerworks/cn/java/j-jtp04298.html#authorN10020" target="_blank" rel="external">Brian Goetz</a> (<a href="mailto:brian.goetz@sun.com?subject=%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E7%AE%80%E5%8C%96%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8" target="_blank" rel="external">brian.goetz@sun.com</a>), 高级工程师, Sun Microsystems</p>
<p>   ​</p>
<p>总之，如果编写广泛使用的类库一定要适当利用通配符类型。记住基本原则：PECS。所有的comparable和comparator都是消费者。</p>
<h2 id="第29条-优先考虑类型安全的异构容器"><a href="#第29条-优先考虑类型安全的异构容器" class="headerlink" title="第29条 优先考虑类型安全的异构容器"></a>第29条 优先考虑类型安全的异构容器</h2><p>通常情况下，泛型运用于集合和单元素容器，限制了固定数目的类型参数，符合我们的需要。但是有时候，我们需要更多的灵活性。比如，数据库行可以任意多的列，如果能以类型安全的方式访问所有列就好了。</p>
<p>幸运的是，有种方法可以非常容易的实现，即把键进行参数化而不是容易参数化。然后将参数化的键提交给容器，来插入或获取值。用泛型系统来确保值类型和键相符。</p>
<p><em>异构的(heterogeneous)解释</em> </p>
<p>容器的键可以是不同类型的，则把这个容器称之为<em>类型安全的异构容器</em> 。</p>
<p>通过一个简单的Favorites类来说明异构过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Class&lt;?&gt;,Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;,Object&gt;();</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type,T instance)</span></span>&#123;</span><br><span class="line">    <span class="comment">//type.cast(instance) 利用类的类型Class的cast方法动态转换成Class对象所表示的类型</span></span><br><span class="line">  	favorites.put(type,type.cast(instance));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">    <span class="comment">//我们需要返回T而不是Object所以也需要动态转换类型</span></span><br><span class="line">  	<span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Favorites f = <span class="keyword">new</span> Favorites();</span><br><span class="line">		<span class="comment">//参数化的键String.class被称为类型令牌，本质是String类类型的实例</span></span><br><span class="line">		f.putFavorite(String.class, <span class="string">"Java"</span>);</span><br><span class="line">		f.putFavorite(Integer.class, <span class="number">0xcafebabe</span>);</span><br><span class="line">		<span class="comment">//参数化的键返回类类型Class的类型令牌Class.class Favorites.class 为类类型为Favorites的类类型实例 Favorites.class</span></span><br><span class="line">		<span class="comment">//每个类都有一个类类型实例，在类被加载后JVM自动构造，由JVM管理。</span></span><br><span class="line">		<span class="comment">//Class类类型Class 是所有类的共有信息抽象</span></span><br><span class="line">		f.putFavorite(Class.class, Favorites.class);</span><br><span class="line"></span><br><span class="line">		String string = f.getFavorite(String.class);</span><br><span class="line">		Integer integer = f.getFavorite(Integer.class);</span><br><span class="line">		Class&lt;?&gt; clazz = f.getFavorite(Class.class);</span><br><span class="line">		<span class="comment">//printf c语言风格的输出 %x 十六进制输出  %n 换行</span></span><br><span class="line">		System.out.printf(<span class="string">"%s %x %s%n"</span>, string, integer, clazz.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出结果</span></span><br><span class="line">	<span class="comment">//Java cafebabe Favorites</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Favorites类put和get方法使用的类型令牌是无限制的，可以接受任何Class对象（类类型实例），有时需要限制传给方法的类型。可以通过有限制类型参数和有限制通配符来限制可以表示的类型。</p>
<p>注解API广泛的使用了有限制的类型令牌。例如接口AnnotatedElement的getAnnotation方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationType)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果有一个Class&lt;?&gt;对象需要传入有限制的令牌类型，直接传入会编译报错。</p>
<blockquote>
<p>捕获capture&lt;?&gt; 意味着某个T，与Annotation及其子类型不相符</p>
</blockquote>
<p>可以把Class&lt;?&gt;改成Class&lt;? extends T&gt;，但这样会报编译未受检的警告（见24条）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Annotation <span class="title">getAnnotation</span><span class="params">(AnnotatedElement element, String annotationTypeName)</span> </span>&#123;</span><br><span class="line">		Class&lt;? extends Annotation&gt; annotationType = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//未受检警告</span></span><br><span class="line">          <span class="comment">//Unchecked cast: 'java.lang.Class&lt;capture&lt;?&gt;&gt;' to 'java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;'</span></span><br><span class="line">			annotationType = (Class&lt;? extends Annotation&gt;) Class.forName(annotationTypeName);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> element.getAnnotation(annotationType);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>幸好，类Class提供了安全的进行转换的实例方法asSubClass，它将调用它的Class对象转换成用起参数表示的类的一个子类。如果转换成功返回参数；如果失败报ClassCastException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Annotation <span class="title">getAnnotation</span><span class="params">(AnnotatedElement element, String annotationTypeName)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; annotationType = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		annotationType = Class.forName(annotationTypeName);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//annotationType类型某个T，安全转换为annotationType的子类</span></span><br><span class="line">	<span class="keyword">return</span> element.getAnnotation(annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，集合API是泛型的一般用法，限制每个容器只有固定的类型参数。通过键类型参数化可以避开这一限制，使得其成为安全异构的容器。可以用Class对象（类类型的实例）来作为键。</p>
<p>也可以定制键类型，例如，用一个DatabaseRow类型表示一个数据库行的容器，用泛型Column&lt;T&gt;作为它的键。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Effective-Java/" rel="tag">#Effective Java</a>
          
            <a href="/tags/generic/" rel="tag">#generic</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/13/EffectiveJava2-类和接口/" rel="next" title="Effective Java -  对所有对象都通用的方法">
                <i class="fa fa-chevron-left"></i> Effective Java -  对所有对象都通用的方法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/22/EffectiveJava2-泛型/"
           data-title="Effective Java - 泛型" data-url="http://bollenchak.github.io/2016/09/22/EffectiveJava2-泛型/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars3.githubusercontent.com/u/5812295?v=3&s=460"
               alt="Bollen" />
          <p class="site-author-name" itemprop="name">Bollen</p>
          <p class="site-description motion-element" itemprop="description">日拱一卒，不求速进</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#泛型"><span class="nav-number">1.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第23条-不要再新代码中使用原生态类型"><span class="nav-number">1.1.</span> <span class="nav-text">第23条 不要再新代码中使用原生态类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第24条-消除非受检的警告"><span class="nav-number">1.2.</span> <span class="nav-text">第24条 消除非受检的警告</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第25条-泛型列表优先于泛型数组"><span class="nav-number">1.3.</span> <span class="nav-text">第25条 泛型列表优先于泛型数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例外"><span class="nav-number">1.3.1.</span> <span class="nav-text">例外</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第26条-优先考虑泛型"><span class="nav-number">1.4.</span> <span class="nav-text">第26条 优先考虑泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类泛型化的步骤"><span class="nav-number">1.4.1.</span> <span class="nav-text">类泛型化的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型化的优势"><span class="nav-number">1.4.2.</span> <span class="nav-text">泛型化的优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第27条-优先考虑泛型方法"><span class="nav-number">1.5.</span> <span class="nav-text">第27条 优先考虑泛型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第28条-利用有限制通配符来提升API的灵活性"><span class="nav-number">1.6.</span> <span class="nav-text">第28条 利用有限制通配符来提升API的灵活性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第29条-优先考虑类型安全的异构容器"><span class="nav-number">1.7.</span> <span class="nav-text">第29条 优先考虑类型安全的异构容器</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bollen</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/vendors/jquery-scrollintoview/jquery.scrollintoview.min.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"bollen"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
